<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Final Project Report</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="FinalReport_files/libs/clipboard/clipboard.min.js"></script>
<script src="FinalReport_files/libs/quarto-html/quarto.js"></script>
<script src="FinalReport_files/libs/quarto-html/popper.min.js"></script>
<script src="FinalReport_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="FinalReport_files/libs/quarto-html/anchor.min.js"></script>
<link href="FinalReport_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="FinalReport_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="FinalReport_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="FinalReport_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="FinalReport_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Final Project Report</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Ria Krishna (2564944), Rishi Khullar (2547490), Keerthy Rangan (2549740) </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<p><strong>Introduction</strong> Our project aims to use the World Bank’s datasets on education to compare the enrollment rate across different school levels for the most populated countries in South Asia, East Asia, and Southeast Asia over the past 55 years.</p>
<p><strong>Data Description</strong> We used three World Bank datasets focusing on education. Each dataset looks at a different school level and its corresponding enrollment rate including primary, secondary and tertiary. Each dataset also looks at a large range of countries and includes enrollment rates starting from 1960. For the purposes of the scope of our project we are only looking at India, Pakistan, and Bangladesh for the South Asia region, China, Japan, and South Korea for the East Asia region, and Indonesia, the Philippines, and Vietnam for the Southeast Asia region.</p>
<p><strong>Data Analysis</strong> <em>Data Cleaning – Python</em> We started our data analysis process by cleaning the dataset. In each dataset for primary, secondary, and tertiary education, the years 1960-1969 had no data. There were also some missing values scattered within the dataset. So, we dropped these years from each of the three datasets, and we also dropped NA values because keeping these would cause issues when we try to create our visualizations. Since we want to analyze enrollment rates for three regions, we had to decide which countries to use for each region. We decided to use the most populated countries in each region. In order to focus on these three countries for each region, we decided to break up each dataset (primary, secondary, and tertiary) into each region. We created a list for the countries in each region – one containing the South Asian countries, one for East Asian countries, and one for Southeast Asian countries. Then, for each dataset we used the “isin” command in Python to filter the dataset to only include countries in the list we created. With that process, we were able to create 9 data tables: Primary South Asia, Secondary South Asia, Tertiary South Asia, Primary East Asia, Secondary East Asia, Tertiary East Asia, Primary Southeast Asia, Secondary Southeast Asia, and Tertiary Southeast Asia. Doing this allowed us to more easily analyze the data we wanted to focus on.</p>
<p><em>Data Analysis – SQL</em> Once we cleaned the data using python, we imported the datasets into SQL by manually typing at the table values we got in Python. Since each of our tables in Python had enrollment averages of all the years included, it was easy to create the tables without importing the csv files into pgAdmin. We first created the structure of the tables using CREATE TABLE statements, with 5 variables representing the country name, country code, indicator name, indicator code, and average enrollment rate. Then, we inserted our values in the table structure using the INSERT INTO statement, and queried all these statements to officially have our 9 tables set up in SQL. After creating all the 9 tables on SQL, we merged each of the South Asian tables, East Asian tables, and Southeast Asian tables together. For each of the mergings, we didn’t use a specific type of join, as we were merging three tables together for all the regions. Our result was three tables with the countries for a specific region as columns, and the rows being the country name, country code, the average primary school enrollment rate, average secondary school enrollment rate, and average tertiary school enrollment rate. After we queried these merges, we imported the data into csv files, which we used to aid in creating our python graphics.</p>
<p><em>Data Visualization</em> To create our visualizations we had to further undergo data cleaning and manipulation. In order to graph enrollment rates over time, we had to convert each year as a row to create a year variable and restructure the format of the table. We did this using the melt function in Python to make the data in a long format. Then, we used the matplotlib package and a for loop to plot each country’s enrollment since 1970 distinguished by different colors. We plotted the different countries in each region by primary, secondary, and tertiary. We then averaged the enrollment rates for each year by region and graphed the averages. This allowed us to see how each region’s enrollment rate changed over the years compared to the others.</p>
<p><strong>Results &amp; Discussion</strong> In order to visualize our results, we created 12 line graphs in Python. The first three graphs show the primary school enrollment rates from years 1970 to 2020, grouped by region. The first graph compares enrollment rates for countries in East Asia, the second compares enrollment rates for countries in SouthEast Asia, and the third compares rates for countries in South Asia. For the East Asian countries, China consistently has the highest enrollment rates until about 2013, where rates for all countries drop. For the countries in SouthEast Asia, Indonesia and Vietnam show an almost opposite trend in enrollment rates – when the rates increase in Indonesia, they appear to decrease in Vietnam. The trend for the Philippines is similar to that of Indonesia. Vietnam’s trend follows a “W” shape, ending at enrollment rates similar to the start in 1970. For countries in South Asia, all three countries show a similar trend in enrollment rates. They all fluctuate a bit from 1970 to 1990, and then they all increase in a linear fashion. While India shows higher enrollment rates consistently, Bangladesh appears to have the higher enrollment rate today. Something to note for these three graphs is that the enrollment rates for primary school are all above 100% – this is something that is present in the original dataset as well, so it is something to consider exploring or evaluating why this may be the case.</p>
<p>Graphs 4-6 show the enrollment rates for secondary school. The three countries in South Asia seem to follow a similar pattern, with enrollment rates drastically increasing from 1990 to early 2000s, and continuing to increase in a fluctuating manner after. Out of the three countries, India consistently has the highest enrollment rates. The Southeast Asian countries followed a relatively positive linear pattern until the mid 2010s, and their enrollment rates are all about the same in the present day. The East Asian countries each show a very different pattern. Japan’s enrollment rates consistently stay the highest and do not change much over the years, while South Korea’s drastically increases and China’s follows a somewhat sinusoidal pattern and has the lowest enrollment rates, which is a stark difference from the results for primary education.</p>
<p>Graphs 7-9 show the enrollment rates for tertiary education. The countries in East Asia all show a similar pattern of enrollment rates, starting at a very low rate in 1960 and increasing drastically. Enrollment rates for schools in Southeast Asia fluctuate more, but they all converge to a similar rate of about 45%. Schools in South Asia show a very similar pattern – enrollment started very low in 1970 and grew heavily in the 2000s.</p>
<p>Graph 10 shows the enrollment rates for secondary education by year for all nine of the countries we focused on. Based on this graph, Japan has had the highest enrollment rates over the years – however, there was no data present for Japan and South Korea after 2000, so we do not know for certain if they still have the highest secondary education enrollment rates. Out of the countries where we do have the data, Indonesia has the highest enrollment rates as of 2023. Graph 11 shows the enrollment rates for secondary education by region. Based on this graph, the rates for each region generally grow in a linear fashion. Between 1970 and 2000, East Asia has the highest enrollment rates but we do not have data for East Asia beyond that. Between South Asia and Southeast Asia, Southeast Asia has higher enrollment rates as of 2023 and the rates are very high, nearing 100%. Graph 12 shows the enrollment rates for tertiary education by region, and we can see that East Asia consistently has the highest enrollment rates over time, with South Asia and Southeast Asia significantly lower.</p>
<p>Graph 1: Primary School Enrollment Rates for East Asia <img src="primaryeastasia.png" class="img-fluid" alt="Primary –&nbsp;East Asia"></p>
<p>Graph 2: Primary School Enrollment Rates for Southeast Asia <img src="primarysoutheastasia.png" class="img-fluid" alt="Primary –&nbsp;Southeast Asia"></p>
<p>Graph 3: Primary School Enrollment Rates for South Asia <img src="primarysouthasia.png" class="img-fluid" alt="Primary – South Asia"></p>
<p>Graph 4: Secondary School Enrollment Rates for South Asia <img src="secondarysouthasia.png" class="img-fluid" alt="Secondary – South Asia"></p>
<p>Graph 5: Secondary School Enrollment Rates for Southeast Asia <img src="secondarysoutheastasia.png" class="img-fluid" alt="Secondary –&nbsp;Southeast Asia"></p>
<p>Graph 6: Secondary School Enrollment Rates for East Asia <img src="secondaryeastasia.png" class="img-fluid" alt="Secondary – East Asia"></p>
<p>Graph 7: Tertiary School Enrollment Rates for East Asia <img src="tertiaryeastasia.png" class="img-fluid" alt="Tertiary –&nbsp;East Asia"></p>
<p>Graph 8: Tertiary School Enrollment Rates for Southeast Asia <img src="tertiarysoutheastasia.jpeg" class="img-fluid" alt="Tertiary –&nbsp;Southeast Asia"></p>
<p>Graph 9: Tertiary School Enrollment Rates for South Asia <img src="tertiarysouthasia.png" class="img-fluid" alt="Tertiary –&nbsp;South Asia"></p>
<p>Graph 10: Secondary School Enrollment Rates for All Countries <img src="secondaryall.png" class="img-fluid" alt="Secondary – All Countries"></p>
<p>Graph 11: Secondary School Enrollment Rates by Region <img src="secondarybyregion.png" class="img-fluid" alt="Secondary –&nbsp;By Region"></p>
<p>Graph 12: Tertiary School Enrollment Rates by Region <img src="tertiarybyregion.png" class="img-fluid" alt="Tertiary –&nbsp;By Region"></p>
<p>Graph 13: Average Tertiary Enrollment Rates by Country <img src="barchart.png" class="img-fluid" alt="Tertiary – Average"></p>
<p><strong>Conclusion</strong> Our project included leveraging different tools across Python and SQL to manage and clean our data as well as provide visualizations. By using the pandas package in Python we created subsets of the large World Bank Data sets to focus solely on three regions in Asia and use matplotlib to plot the relationships between different countries and regions. Our main findings support that, despite starting at a relatively similar enrollment, East Asia has had the largest increase in higher education enrollment rates since 1970 compared to South and Southeast Asia. We believe this partly to be due to different government structures and economic states within each region.</p>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>